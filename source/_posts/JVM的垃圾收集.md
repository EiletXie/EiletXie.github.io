---
title: JVM的垃圾收集
date: 2019-10-25 8:30:22
tags:
- JVM
categories:
- JAVA
toc: true



---



## 如何判断一个对象是否可以回收呢？

​        简单的说就是 怎么确定这个对象是个垃圾。

有两种解决方案：

###  引用计数算法(reference counting)：

        判断机制：  给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1 ，当引用失效时，计数器值就减 1；当任何时候计数器都为 0 的对象就是不可能再被使用的。

​    优点：引用计数算法（Reference Counting）的实现简单，判断效率很高，如微软的COM计数、Python语言以及游戏脚本领域中被应用的Squirrel 等都使用了该算法进行内存管理。

​    缺点：Java语言中没有选用引用计数算法管理内存。最重要的原因就是它无法解决对象之间相互循环引用的问题！！

<br/>

<!--more-->

### 可达性分析算法

        通过一系列的GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），

当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

​        这里会引发出一个问题，对，哪些算是GC Roots对象呢？

<br/>

### 可作为GC Roots的对象

- 虚拟机栈中引用的对象 （栈帧中的本地变量表）

- 方法区中的常量引用的对象

- 方法区中的类静态属性引用的对象

- 本地方法栈中JNI (Native 方法）的引用对象

  



ps: 如果是对这些对象很模糊，建议看一下相关的 JVM内存管理这块的内容。

<br/>

## 垃圾收集算法

### 标记-清除（Mark-Sweep）算法

​        最基础的垃圾收集算法是 “标记-清除”（Mark - Sweep） 算法，如它的名字一样，算法分为“标记” 和 “清除” 两个阶段； 首先标记处所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

缺点： 由于被回收的对象之间是不连续的，会造成内存碎片，当大对象存入时可能会因为碎片内存太小，无法插入，从而重新进行内存回收。

{% asset_img mark-sweep.jpg copying%}

<br/>

### 复制算法-Copying



​        它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当其中一块的内存用完了，就将该块还存活着的对象复制到另外一块上面，然后把已使用过的这块内存空间一次清理完，这样每次都只对其中一块进行内存回收，不需要考虑内存碎片等问题，实现简单，运行高效。

{% asset_img copying.jpg copying%}

<br/>

**缺点：** 内存使用为原来的一半。

**特点：**

-  解决碎片化问题
- 顺序分配内存，比较高效
- 比较适合 对象存活率低的场景





​      现在的商业虚拟机都采用这种收集算法来回收新生代对象。但把内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中的一块Survivor。当回收时将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survior空间上，最后清理掉Eden和刚才使用过的Survivord 的空间。HotSpot 虚拟机中 Eden 和 Survivor 的大小比例是 8：1





### 标记-整理算法Compacting

标记： 从根集合进行扫描，对存活对象进行标记

清除： 移动所有存活的对象，且按照内存地址次序依次进行排列，然后将末端内存地址以后的内存全部回收

特点：

- 解决了内存碎片的问题
- 不用浪费一半的内存进行复制
- 适用于对象存活率高的场景

{% asset_img compacting.jpg compacting%}

<br/>

### 分代收集算法（Generational Collector)

​     按照不同区域的对象存活频率来针对的配置 垃圾回收算法，这样效率是最高的

​      现在的商业虚拟机的垃圾收集都采用 “分代收集” （Generational Collection）算法，它是按照对象的存活周期的不同将内存划分为几块。一般将Java堆划分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。 在新生代中，每次垃圾收集中都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要复制少量存活对象，有效降低了复制收集成本。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法进行回收。

<br/>

## 垃圾回收操作

### Minor GC :

​     从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。



### Major GC:

​    针对老年代空间内存回收，其发生之前往往至少会发生一次 Minor GC



 <br/>

### FULL GC: 

​       整个堆空间的内存统一回收（包含年轻代和老年代），通常使用 标记-清除 或者 标记 - 整理算法。

触发条件：

- 当老年代空间不足时
- JDK7及以下版本永久代空间不足，（永久代,年轻代、老年代这3块区域在堆中，JDK8就没有永久代了，与之替代的是使用本地内存的MetaSpace 元空间）
- CMS GC时出现 promotion failed（新建的大对象，年轻代和老年代都放不下时），concurrent mode failure
- Minor GC晋升老年代的平均大小 大于 老年代的剩余空间 （ 提前检测，智能啊）
- 程序中调用 System.gc()
- 使用RMI来进行RPC或者管理的JDK应用，每小时执行一次 FULL GC

 <br/>

Minor GC时， 存活的对象会移动到 From 区域即 Survivor，年龄为 1，将to区域的存活对象移动到 from区域，年龄也 +1，清空To区域

重新交换名称， From 变成了 To, To此时移动了所有对象，区域为空，变成了 From 区域。

{% asset_img survivor.jpg survivor%}

Eden区： 对象被创建时放置的区域



### 对象如何晋升到老年代

- 经历一定Minor 次数依然存活的对象
- Survivor区中存放不下的对象
- 新生成的大对象（ -XX: + PretenuerSizeThreshold)

 <br/>

#### 常见的调优参数

\- XX:SurvivorRatio： Eden 和 Survivor的比值，默认为 8： 1

\- XX:NewRatio: 老年代和年轻代内存大小的比例，默认 2：1

\- XX:MaxTenuringThreshold: 对象从年轻代晋升到老年代经过GC次数的最大阈值 ，默认15

<br/>

#### Survivor区对象晋升位老年代对象的条件

​         Java虚拟机会记录 Survivor区中的对象一共被来回复制了几次。**如果一个对象被复制的次数为 15 (对应虚拟机参数 -XX:+MaxTenuringThreshold),那么该对象将被晋升为至老年代**，(至于为什么是 15次，原因是 HotSpot会在对象头的中的标记字段里记录年龄，分配到的空间只有4位，所以最多只能记录到15)。

​         另外，**如果单个 Survivor 区已经被占用了 50% (对应虚拟机参数: -XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代。**

<br/>



#### Stop-the-World 

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少 Stop-the-world

<br/>

#### Safepoint

- 分析过程中对象引用关系不会发生变化的点
- 产生Safepoint的地方： 方法调用，循环跳转，异常跳转等
- 安全点数量得适中

个人理解： 清理某一个区域，如果不能边清理边产生垃圾对象，则需要将这块区域冻结，停止除了垃圾回收线程外的用户线程操作，这块区域就叫做安全点

<br/>



## 常用的垃圾收集器

### 年轻代的垃圾收集器

#### Serial 收集器 

- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的年轻代收集器
- -XX: + UseSerialGC ,基于复制算法设计

<br/>

#### ParNew收集器 

- 多线程收集，其余的行为、特点和Serial收集器一样
- 单核执行效率低于Serial，在多核下执行才有优势
- -XX：+ UseParNewGC,基于复制算法设计

<br/>

#### Parallel Scavenge收集器 

- 比起前面的收集器关注用户线程停顿时间而已，该收集器更关注系统的吞吐量（ 吞吐量 = 用户代码执行时间  / (用户代码执行时间 + 垃圾收集时间))
- 在多核下执行才有优势，Server模式下默认的年轻代收集器
- 配置： -XX： + UseParallelGC,基于复制算法设计

<br/>

**这里说明一下：** 

停顿时间短意味着与用户交互更频繁，响应速度快，用户体验好。

高吞吐量意味着 CPU的更高效，后台运算性能更佳，适合交互不多的任务。

所以需要根据 系统项目使用的场景来选择相应特点的垃圾收集器。

<br/>



### 老年代的垃圾收集器

#### Serial Old收集器

- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的老年代收集器
- -XX: UserSerialOldGC, 基于标记-整理算法设计

<br/>

#### Parallel Old收集器 

- 多线程，吞吐量优先
- 常与 Parallel Scavenge 这一新生代收集器搭配，适用于 注重吞吐量以及CPU资源敏感的场合
- -XX： + UseParallelOldGC,基于标记-整理算法设计

<br/>

#### CMS收集器

特性：

-  跨时代产品，实现了与用户进程并行的垃圾并发收集
-   以获取最短回收停顿时间为目标的收集器，
-   适合 要求系统停顿时间短，服务响应速度快的应用。
- -XX: +UseConcMarkSweepGC,基于标记-整理算法设计



在周志明出版的深入了解Java虚拟机书中

将CMS收集器的运作过程分为4步

- 初始标记（CMS  initial mark)
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

<br/>

#### G1收集器

G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。

- 并行与并发

- 可预测的停顿

- 分代收集

- 空间整合

  

配置参数： -XX: +UserG1GC，基于复制+标记-整理算法设计

说明： 由于 CMS与G1垃圾收集器很重要，我将其单独写成一篇博客了来介绍其工作流程和设计思路，这篇我只介绍其特点。



### JVM的垃圾收集器之间的组合搭配。

​       根据垃圾收集器特性，其新生代的垃圾收集器可不能随意地与老年代收集器组合，不同JDK版本诞生的收集器相互之间的兼容性和特性是不同的。

   下图为 垃圾收集器可搭配使用图。



{% asset_img generation.jpg generation%}