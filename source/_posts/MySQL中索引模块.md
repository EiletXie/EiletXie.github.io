---
title: MySQL中索引模块
date: 2019-10-07 09:00:04
tags:
- MySQL
- 索引
categories:
- 数据库
toc: true

---

## 索引模块

我们通过问题来了解MySQL中索引模块相关的知识

### 为什么要使用索引？

因为索引能够避免全表扫描，提升查询的效率和速度



### 什么样的信息能够成为索引？

主键，唯一键等能让数据具备一定区分的字段



### 索引的数据结构

B-Tree 、 B+-Tree、 BitMap、 Hash



### 索引数据结构的推理

#### 二叉树可以满足吗？

一种极端的情况是 根节点为最大值或者最小值时，那么二叉树就退变成了一个链表

所以 PASS掉 

<br/><!--more-->

#### 那平衡二叉树可以满足吗？

用平衡二叉树，当左右子树高度相差大于1时，进行左旋右旋自平衡操作

这种的查找时间复杂度 O(log2(n))

1、如果数据量为一百万时，树的高度为20，10亿数据量，数的高度为30

2、查询效率不稳定，如果查询的数据落在根节点，只需要一次IO，如果是叶子节点或者是支节点，会需要多次IO才可以。

3、节点存储的数据内容太少。没有很好利用操作系统和磁盘数据交换特性，也没有利用好磁盘IO的预读能力，这一点在下面谈谈自己理解。

<br/>

#### 那有没有一种结构能够解决二叉树的这种问题呢？

有，多路平衡查找树：（Balance Tree）：

B Tree 是一个绝对平衡树，所有的叶子节点在同一高度，如下图所示：

详细可以查看这篇博客： https://my.oschina.net/u/3370829/blog/1301732



### 谈谈自己对于 树与磁盘IO次数的关系的理解

树的节点是存在 磁盘的页中的，

之所以树高度越高，磁盘IO次数越多，是因为一颗多阶树的每个节点是存放指针指向 页面的，一个页面中存放的就是就是一个节点指向的指针和节点的大小。

当阶数为2时，一个磁盘页面存放的就是左节点指针和右节点指针和当前节点值 ， 二叉平衡树的高度为3时，如果目标节点为叶子节点，那么它就得经过3次比较，读取3个磁盘页面，做3次IO操作。

那如果阶数是1001呢？ 那一个磁盘页面就可以存放的是 1000个值和1001一个指针。那假设它的目标节点也是 叶子节点并且高度为3，那这个总数据量是多少？  1000的3次方，10个亿的数据量。

这就是多阶平衡查找树的厉害之处，基本你的目标数据在树的高度为2-3，也就是你的磁盘IO次数只要2，3次。

那如果10亿数据量放在二叉平衡树中，树的高度是多少呢？

30次 ，如果是二叉平衡树，你最多需要寻找 30次。

这就是为什么要选择 多阶平衡查找树的原因。



系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。**InnoDB存储引擎中默认每个页的大小为16KB**，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在[MySQL](http://lib.csdn.net/base/mysql)中可通过如下命令查看页的大小：

*show variables like 'innodb_page_size';*

{% asset_img page_size.jpg page_size%}

<br/>

### B-Tree规则：

（1）树种的每个节点最多拥有m个子节点且m>=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）；

（2）除根节点外每个节点的关键字数量大于等于ceil(m/2)-1个小于等于m-1个;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)

（3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子

（4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1;

（5）所有节点关键字是按递增次序排列，并遵循左小右大原则；



**B TREE和B+TREE区别是什么？**

1、B+TREE 关键字的搜索采用的是左闭合区间，之所以采用左闭合区间是因为他要最好的去支持自增id，这也是mysql的设计初衷。即，如果id = 1命中，会继续往下查找，直到找到叶子节点中的1。



2、B+TREE 根节点和支节点没有数据区，关键字对应的数据只保存在叶子节点中。即只有叶子节点中的关键字数据区才会保存真正的数据内容或者是内容的地址。而在B树种，如果根节点命中，则会直接返回数据。并且在B+TREE中，叶子节点不会去保存子节点的引用。



3、B+TREE叶子节点是顺序排列的，并且相邻的节点具有顺序引用的关系，如上图中叶子节点之间有指针相连接。

{% asset_img baddtree.jpg baddtree%}

<br/>

**MYSQL为什么最终要去选择B+TREE？**

注意这里可以不是3阶，多阶平衡树，可以设计多少阶就是多少阶

1、B+TREE是B TREE的变种，B TREE能解决的问题，B+TREE也能够解决（降低树的高度，增大节点存储数据量）



2、 B+TREE扫库和扫表能力更强，如果我们要根据索引去进行数据表的扫描，对B TREE进行扫描，需要把整棵树遍历一遍，而B+TREE只需要遍历他的所有叶子节点即可（叶子节点之间有引用）。



3、B+TREE磁盘读写能力更强，他的根节点和支节点不保存数据区，所有根节点和支节点同样大小的情况下，保存的关键字要比B TREE要多。而叶子节点不保存子节点引用。所以，B+TREE读写一次磁盘加载的关键字比B TREE更多。



4、B+TREE排序能力更强，如上面的图中可以看出，B+TREE天然具有排序功能。



5、B+TREE查询效率更加稳定，每次查询数据，高度波动不大。

### 哈希索引

基于哈希表实现，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（利用索引列对应的键值来计算）

哈希索引将所有的哈希码存储在索引中，同时在哈希表保存指向每个数据行的指针。

<br/>

**优点：** 

索引只需存储对应的哈希值，所以结构紧凑，查找速度非常快

**缺点：**

哈希索引数据并不是按照索引值顺序存储，所以无法用于排序或任何的范围查询

当出现哈希冲突时，存储引擎必须遍历链表中的所有对应行的引用，逐行比较，直到找到符合全部条件的行。所以当哈希冲突多的时候，索引的维护操作就很高，表中没删除一行，存储引擎需要遍历对应哈希值的链表中每一行，找到并删除，冲突越多，代价越大。



### 密集索引和稀疏索引的区别

密集索引：

叶子节点保存的是整行数据，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引

稀疏索引：

叶子节点仅保存了键位信息以及该行数据的地址，有的稀疏索引只保存了键位信息机器主键



聚簇索引：

表数据按顺序存储，即索引顺序和表记录物理存储顺序一致。

聚簇索引 叶子节点存储数据行和B-Tree索引。

在一个表中只能有一个聚簇索引，因为真实物理存储顺序只能有一种



#### InnoDB:

**表** 根据主键顺序以**B+ 树索引的形式存放**的,

这种存储方式的表称为**索引**组织表

- 主键索引(**聚簇索引**): 叶子节点存的是整行数据 是 密集索引
- 非主键索引(**二级索引**): 叶子节点内容是主键的值, 是稀疏索引

  有且只有一个密集索引。密集索引的选取规则如下：

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innoDB内部会生成一个隐藏主键（密集索引，默认6字节，随着表增大而增大）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

{% asset_img innodb.jpg innodb%}

<br/>



#### MyISAM 

对MyISAM 来说, 主键索引和其他索引没有任何区别, 都是稀疏索引 , 

表数据存储在独立的地方, 表数据和索引的分开的, 索引用地址指向表数据



表person_info_large是InnoDB表

表shop_info_small是MyISAM表（该模式下 索引和数据是分开存放的，看后缀MYI是文件是存放索引的，MYD是存放数据的，这里特意没有插入数据）

{% asset_img myisam.jpg myisam%}

<br/>



## 索引衍生的面试题：

### 如何定位并优化慢查询Sql

大致思路

1. 根据慢日志定位慢查询Sql
2. 使用explain等工具分析sql
3. 修改sql或尽量让sql走索引

<br/>

{% asset_img log_setting.jpg log_setting%}

slow_query_log 慢日志是否开启，默认OFF

slow_query_log_file: 慢日志地址

long_query_time： 默认10s,当sql语句执行超过默认值就记录到慢日志中



SHOW STATUS LIKE '%slow_queries%'  查询慢查询的数量

首先：打开慢日志记录,设置默认为慢查询的执行时间为 1S

*SET GLOBAL SLOW_QUERY_LOG = ON;*

*SET GLOBAL LONG_QUERY_TIME = 1;*

注意，这里要关闭连接再重连数据库才能生效

<br/>

当我们有一条查询语句执行超过1S，就会记录下来

{% asset_img slow_log.jpg slow_log%}

实际花费了 query_time： 6.33 S

<br/>

可以在查询语句前+ EXPLAIN 进行分析

{% asset_img explain.jpg explain%}



### EXPLAIN重要列字段含义

#### type

***system > const > eq_ref > ref > fulltext > ref_or_null > index_merge >***

***unqiue_subquery > index_subquery > range > index > all***

当 type = all，说明是全表扫描

<br/>

#### extra

{% asset_img extra.jpg extra%}



### 联合索引的最左匹配原则成因

最左匹配原则： 联合索引只匹配 左侧索引或者全部索引,当从左至右遇到范围查询 （>,<,between,like) 就停止匹配，只使用之前匹配的作为索引。

如果是 = 或者 in 可以乱序，mysql可以识别

#### 示例1： 

User表有一个联合索引 Index_find(name,country) ，

则当 查询语句 where name = '' and country = '' 走的是 index_find索引 

当 where name = ' '  走的也是联合索引

当 where country = ' '  ； 时如果没有country列的单独索引就会走全表扫描 用 explain查看 type = all

#### 示例2：

  demo表中 有 一个联合索引 index_find( A,B,C,D)

那么当 where A= 1 AND B = 1 AND C > 1 AND D = 1 时，匹配到 C > 1会终止匹配，注意：会使用索引，索引为 （A,B,C)

{% asset_img s1.jpg s1%}

当我让 C为范围查询时， 联合索引到 C终止，注意是执行了联合索引了的， 只是执行的是 （A,B,C)这个联合索引，这个表中的一个key的长度为5

此时你估计会有疑问，不是只有一个联合索引（A,B,C,D)吗？ ，其实这个联合索引是包含从左侧开始的索引的 如： （A),(A,B),(A,B,C)

{% asset_img s2.jpg s2%}

当我们不执行C的范围查询时，这个时候用的是 （A,B,C,D) 这个 20长度的联合索引

{% asset_img s3.jpg s3%}

<br/>

**注意这个where 检查顺序是按照联合索引从左至右的检测的**

当我们把索引改为 (A,B,D,C)时

{% asset_img index.jpg index%}

发现C执行范围查询并不影响D的并入，**因为 D在 C的前面**

{% asset_img left.jpg left%}



### 索引越多越好吗？

一个索引的建立意味着要用额外的空间记录 索引列对应表数据的地址

{% asset_img index_show.jpg index_show%}

数据变更的用时要维护索性，更多的索引意味着更多的维护成本

所以当数据量较小的时候，是没有必要维护索引的。