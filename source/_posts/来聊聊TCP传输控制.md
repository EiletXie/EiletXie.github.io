---
title: 来聊聊TCP传输控制
date: 2020-03-30 15:15:36
tags:
- TCP
categories:
- 计算机网络
toc: true
---

​           每次我看看TCP为了保证可靠传输，涉及到的滑动窗口、流量控制、拥塞控制，总是看得事前迷迷糊糊，事后转身就忘，这怎么能行呢？我谢某人怎么能做摸鱼怪呢 ！！今天必须整明白，理解透。

<!--more--> 

### 基础预备：

TCP可以保证可靠传输，那就应该有数据的发送方和数据的接收方，两个端点吧。

RTT: 发送方发送一个数据包到 收到 接收方回复的ACK确认信息，这样一个来回所花费的实际时间

RTO: 重传时间间隔，假如发送方发的数据在网络中丢了，是不是要定时计算一下，一定时间内没收到ACK信号就重传呀。



### 让你来保证可靠传输，你怎么弄？

按照正常的思维，我发一个东西给你，你收到了就回复收到了，没收到就不回复，过段时间我还没有听到你说收到，我就再发。

{% asset_img transport.jpg 可靠传输%}

通过图片我们可以了解到，要发送的数据被切分成了多个数据包，然后进行编码发送。

每发送一个数据包，接收方就要回复一次我收到了的 ACK确认标志。

当某一个数据包在网络中丢失时，那么客户端会进行重传，因为它没有收到接收端的ACK信号。

**注意：** 每个数据包都会有一个对应的 计时器。计时时间略大于平均的RTT一次往返的时间。这样当大于指定时间了该数据包还未收到确认信息时，就会超时重传。



### 上面的这份做法有什么缺点？

我们发现发送方每次发送一份数据包就得等待接收端的ACK信号，这种做法是不是太低效了点！！！

{% asset_img RTT.jpg RTT%}

#### 怎么说？

就好像你淘宝在一个商店买了一大堆东西，结果它是打算一天发一件给你，你必须回复收到它才再发一件，这样玩，几个月才可以发完，是不是想吐血。

有什么好办法呢？

<br/>

### 流水线的发送方式

{% asset_img water_RTT.jpg  流水线RTT%}

假设接收方可以无限接收，那么发送方可以不停的发送数据包给接收方，接收方收到了就发送ACK确认序号，某个数据包没收到ACK的话发送方重发就好了。

#### 这样做的好处是什么？

信道利用率大幅提升了，我们不需要每发送一次数据包就傻傻的等着对应的ACK确认信号，可以不停的发送。

#### 这样做的缺点呢？

前面我说明，是假设接收方可以无限接收的前提下，才能做到流水线的传输方式，可问题来了，接收方能力有限呀，发送方有自己的发送缓存，接收方有自己的接受缓存。通常来说发送方的发送速度是要看接收方的当时处理能力来的。

<br/>

#### 怎么说？

​         这种莽夫式的发法比最初的发送方式（发一个接受一个）的这种要好许多，信道利用率高，发送频率高，但是这种方法太莽夫了，你要考虑一下接收方大爷的胃口呀，不能接收方装不下了你发送方还塞个不停，为了双方的性能考虑，就出来了一个流量控制和接收缓存以及发送缓存。

<br/>

### 举个栗子

比如接收方现在说来吧，我现在可以接受1000字节的数据包，发过来吧。

这时候发送方就按照接收方的要求发送了一个1000字节的数据包给它，好，接收方收到数据包后，接受缓存直接快满了，这个时候怎么办，是不是要消化一下，把数据写入到磁盘，再清理自己的**接受缓存**从而接收新的数据吧。

这个时候接收方可能就说不行了，发送方老哥，你之前发送的数据包我收到了，但是你要悠着点，我有点顶不住了，我现在只能接受2个字节的数据包了。

发送方收到后，说好的，把之前**发送缓存**中存的1000字节的数据包删除了，填入新的数据，再给接收方发送了一个2个字节的数据包。

就这样不停的来回的发送和接受，直到把整个数据发送完毕。

<br/>

现实的tcp通信更贴近于上面说的这个小例子，而不是莽夫一样的直接全部把数据甩给接收方。

这就涉及到了两个概念 **TCP的流量控制和滑动窗口**了。

这个时候相信大家可以大概理解流量控制，控制的是啥？

无非就是接收方告诉 我现在的接受量（也就是滑动窗口的窗口大小）是多少，发送方按照接收方的当前窗口大小来调整对应的发送数据的大小。

<br/>

### 滑动窗口

{% asset_img window.jpg  滑动窗口%}

这里的滑动窗口是指的我们的发送方有一个发送窗口，接收方有一个接受窗口

**注意： 发送窗口是根据 接受窗口的大小来调整自身大小的**



这里假设当前接收方B的接受窗口大小是20

目前 发送方A已经发送序号1-30的字节数据了，并且接收方B已经成功接受了1-30序号的数据，已经从接受缓存删除，存入到磁盘作为一个临时文件了。

这个时候发送方A的滑动窗口就是存放了序号从 31-50总共20个字节的数据，其中序号31-41已经发送到接收方B了，但是还未确认。

**注意**： 这里发送窗口中数据都可以发送，也就是即使 序号31-41的数据还未确认，但是序号42-50的数据仍然可以接着发送。

但是如果窗口中的数据发送完了，就必须要等待接收方的确认，如果没有及时收到确认就要超时重发了。



这个时候 假设接收方B的接受窗口中，只接受到了31，以及34-41，怎么办？

那么接收方B会回复一个 ack = 32这样一个确认信号给接收方A。

**什么意思？**

​         为啥是回复一个确认序号ack =32呢？ 简单来说就是告诉发送方A说，31和之前的连续数据我已经收到了，你发送从32开始的数据给我吧。

​         这个时候发送A收到确认信号 ack =32后，就明白，哎呀，我之前发送的32-41的数据，这家伙只收到了31，算了，接着重新发 32以后的数据。

​          你可以理解成 接收方是绝对的大爷，它想怎么样就怎么样，发送方必须按照它的胃口来发送数据。

<br/>

#### 但是我们不是说的是滑动窗口吗，你倒是滑动呀！

别急，这里假设 接收方B收到了序号32-41的数据了，它会干什么？ 它会回复一个 ack=42的信号，告诉发送方可以发送序号42以后的数据了,前面的我已经收到了。

然后 接收方B会把接收窗口滑动准备接收序号 42-61的数据，并将收到了序号31-41的字节数据写入磁盘的临时文件中同时将接收缓存中的序号31-41的接受数据删除。

而发送方收到接收方发来了确认信号 ack = 42后，它也会滑动发送窗口，对应准备发送 序号42-61的数据，并且将之前发送缓存中的31-41的数据删除，进而可以放入新的数据。

<br/>

### 流量控制

前面说了流量控制，那么现实中是如何实现流量控制的呢？

刚才举的例子，大家理解的话，其实这里也是一样的。那就接收方按照自己处理数据的速度，动态调整接收窗口大小，并且发送信号告诉发送方自己的接收窗口大小，要求发送方按照接收窗口的大小来调整发送窗口的大小。

<br/>

### 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞（congestion）。

​    在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。

若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。

#### 怎么说，我来翻译一波：

​         就是有时候，接收方需求大，有钱了，要更多的货了，但是通往接收方的马路（网络带宽）只能同时走两辆马车，中途的驿站只能装下几吨货物，你这个时候说要几百吨马上送来，这不是步子迈太大，扯着裆吗？到时候一群人和货物全部堵死在马路上，这就凉凉了。



前面流量控制说过，发送方要按照接收方大爷的要求来，接收方大爷今天想要多少，发送方就按照今天的要求发多少。

但是可惜的是，发送方不仅仅只有一个大爷，它还有一个二大爷-网络，网络二大爷今天心情好，马路好走，就尽量按照两位大爷的要求来，二大爷心情不好，有马匪，发送的货物数据被人抢了不少，丢包了，肯定不能傻傻的送货了呀，咋办？接着往下看！

{% asset_img block.jpg  拥塞与非拥塞%}

<br/>

既然网络时好时坏，那就要得想出解决办法来。

#### Tcp的四种拥塞控制算法

- 慢开始（slow-start）
- 拥塞避免（congestion avoidance）
- 快重传（fast retransmit）
- 快恢复（fast recovery）

下面来介绍这四种策略的基本原理，这里为了方便介绍拥塞控制，假设如下条件

1、数据是单方面传送，而另一个方向只传送确认。

2、接收方总是有足够大的缓存空间，因而发送方窗口的大小由网络的拥塞程度来决定。

3、以TCP报文段的个数作为讨论问题的单位，而不是以字节为单位。



你可以简单理解为，接收方大爷是个无底洞，发送方只需要考虑如何根据 网络二大爷的心情，最大速度的发送数据并保证货物的完整。

{% asset_img cwnd.jpg  端点拥塞%}

<br/>

发送方维护一个叫做 **拥塞窗口cwnd** 的状态变量，其值**取决于网络的拥塞程度**，并且**动态变化**。

- ​    拥塞窗口**cwnd的维护原则**： 只要网络没有出现拥塞，拥塞窗口就再增大一些，但是一旦网络出现拥塞，拥塞窗口就减少一些。
-    判断出现网络拥塞的依据： 没有按照收到应当到达的确认报文（即发生超时重传）。

发送方将拥塞窗口作为发送窗口，即swnd = cwnd

维护一个慢开始门限 **ssthresh** 状态变量：

-    当cwnd  < ssthresh 时，使用慢开始算法；
-   当 cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法；
-   当cwnd = ssthresh时，即可使用慢开始算法，也可使用 拥塞避免算法。

<br/>

#### 怎么说，再翻译一波：

​         首先， 把要送的货物总批数 取个名字，叫 总批数cwnd，刚开始2的指数增长，但是这个指数增长的玩法不能超过 保险数量 ssthresh，我刚开始不怕死，为了赚钱，满足接收方大爷的要求，每次翻倍的发货，从第一天发1批，第二天发2批，第三天发4批，第4天发8批，到第5天的时候你发了16批 到了保险数量 ssthresh，这个时候我有点怂了，万一我今天的货被马匪劫了，那我不是亏大了！！这个时候拥塞避免算法，我怕货被劫但是我又想多赚点，怎么搞？ 算了，每天多加一批，这就很舒服。

​        突然有一天，马匪来了，觉得你这只羊养肥了可以割一下韭菜了，你的货损失惨重。怎么办？没办法，生意还是要做，大爷还是要供着。只是我怂一点，重新开始，从第一天发1批货这样来指数增长，但是保险数量得改一改，ssthresh 等于 你被马匪截的那天总批数的一半。 这样到时候只长肥一半的羊估计马匪应该还想再养一会，我可以趁着和平日子多赚点钱。

{% asset_img slow_start.jpg  慢开始%}

- “慢开始” 是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd增长速度慢；
- “拥塞避免” 并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞；



<br/>

慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法（TCP Tahoe版本）

1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和快恢复（TCP Reno版本）

有时候，个别报文段会在网络中丢失，但实际上网络并发生拥塞。

这将导致发送超时重传，并误以为网络发生了拥塞；

发送方错误启动慢开始算法，并把拥塞窗口cwnd又设置为最小值1，因为降低了传输效率

<br/>

#### 快重传算法

采用快重传算法可以让发送方尽早知道了个别报文段的丢失。

所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。

- 要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立即发送确认**；
- 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
- 发送方一旦收到**3个连续的重复确认**，就将相应的报文段**立即重传**，而不是等该报文段的超时重传计时器超时再重传。
- 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提供约20%。

{% asset_img quick_return.jpg  快重传%}

<br/>

#### 怎么说？翻译一波

​        有一天我，湖南小霸王，听我手下说我的货又又又一次被马匪抢劫了，我还是按照打算按照套路  慢开始，从1开始，再拥塞避免，猥琐的发送货物。但是接收方大爷跟我说你的货不是被抢了，是你手下删库跑路了！ 你不要怕，赶紧发货，记得按顺序来，哪一批货没了，我就重复告诉你3次，3次过后你不发过来，我就把我的意大利炮给你看看。

​       我，湖南小霸王，没得办法，面对威胁只能服气，老老实实的把今天的货批数cwnd 等于被抢之前的一半，按照编好的顺序，每天多发送一批，遇到发送方大爷的狗腿子告诉我3次哪批货少了，我就得赶紧重新把对应的货补上重发，直到全部发完为止。

#### 综合图如下：

{% asset_img all_transport.jpg  全部的拥塞重传%}



<br/>

### 结语：

​        相信到这里，大家对TCP的滑动窗口、流量控制、拥塞控制都要一定的认知和理解了，我也发现网络这块知识，如果整体去理解某个协议的发展过程，比单一的去理解某个知识点效果要好很多。



#### 参考：

这里的很多知识来源于 B站中的 湖科大教书匠和 韩立刚老师的网络教程。复习计算机网络这块知识，推荐看这两个up主的视频。